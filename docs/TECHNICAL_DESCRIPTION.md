# Техническое описание реализации

## 1. Общая архитектура системы

AI Career Pathfinder представляет собой веб-приложение с клиент-серверной архитектурой, объединяющее методы NLP, семантического поиска (RAG) и генеративного ИИ для построения персонализированных планов карьерного развития.

Система развёрнута как единый сервис: Python-бэкенд обслуживает REST API и одновременно раздаёт статические файлы React-фронтенда. Такой подход исключает необходимость в отдельном веб-сервере и упрощает деплой.

### 1.1. Архитектурная схема

```
┌──────────────────────────────────────────────────────────┐
│                      Клиент (браузер)                    │
│  React 19 + TypeScript + Tailwind CSS                    │
│  5 экранов: Welcome → Цель → Навыки → Проверка → План   │
└──────────────────────┬───────────────────────────────────┘
                       │ HTTP (JSON / multipart)
┌──────────────────────▼───────────────────────────────────┐
│                   FastAPI (api.py)                        │
│  REST API + SPA fallback (раздача frontend/dist)         │
├──────────────────────────────────────────────────────────┤
│                   Слой бизнес-логики                      │
│  ┌─────────────┐  ┌──────────────┐  ┌─────────────────┐ │
│  │ scenario_    │  │ gap_         │  │ output_         │ │
│  │ handler      │  │ analyzer     │  │ formatter       │ │
│  └──────┬──────┘  └──────────────┘  └────────┬────────┘ │
│         │                                     │          │
│  ┌──────▼──────────────────────────┐  ┌──────▼────────┐ │
│  │ next_grade_service              │  │ plan_         │ │
│  │ switch_profession_service       │  │ generator     │ │
│  │ explore_recommendations         │  │ (OpenAI)      │ │
│  └─────────────────────────────────┘  └───────────────┘ │
├──────────────────────────────────────────────────────────┤
│                   Слой данных и NLP                       │
│  ┌──────────────┐  ┌───────────────┐  ┌───────────────┐ │
│  │ data_loader   │  │ skill_        │  │ rag_service   │ │
│  │ (JSON)        │  │ normalizer    │  │ (Qdrant +     │ │
│  │               │  │ (NLTK)        │  │  Embeddings)  │ │
│  └──────────────┘  └───────────────┘  └───────────────┘ │
│  ┌──────────────┐                                        │
│  │ resume_      │                                        │
│  │ parser       │                                        │
│  │ (OpenAI)     │                                        │
│  └──────────────┘                                        │
├──────────────────────────────────────────────────────────┤
│               Внешние сервисы                            │
│  OpenAI API (GPT-4o)    Qdrant Cloud (опционально)       │
└──────────────────────────────────────────────────────────┘
```

### 1.2. Поток данных

Обработка запроса на построение плана проходит через следующие этапы:

1. **Ввод данных** — пользователь выбирает профессию, грейд, сценарий и добавляет навыки (вручную или из резюме).
2. **Маршрутизация сценария** — `scenario_handler` определяет тип запроса и загружает требования для целевой роли/грейда из `data_loader`.
3. **Анализ разрывов** — `gap_analyzer` сопоставляет навыки пользователя с требованиями роли, вычисляет дельты и приоритеты.
4. **Обогащение контекстом** — `rag_service` извлекает семантически релевантные фрагменты из векторной базы для пояснения разрывов.
5. **Форматирование диагностики** — `output_formatter` собирает структурированный отчёт (шаг 1).
6. **Генерация плана** — `plan_generator` передаёт диагностику и RAG-контекст в GPT-4o для формирования плана по модели 70/20/10 (шаг 2).
7. **Отображение** — фронтенд рендерит полученный Markdown с оглавлением, кнопками копирования и скачивания.

---

## 2. Технологии и инструменты

### 2.1. Бэкенд

| Технология | Версия | Назначение | Обоснование выбора |
|---|---|---|---|
| **Python** | 3.12 | Основной язык | Богатая экосистема ML/NLP-библиотек; поддержка типизации; широко используется в Data Science |
| **FastAPI** | ≥ 0.100 | REST API фреймворк | Асинхронность из коробки; автогенерация OpenAPI-документации; встроенная валидация через Pydantic; высокая производительность среди Python-фреймворков |
| **Uvicorn** | ≥ 0.22 | ASGI-сервер | Стандартный сервер для FastAPI; поддержка HTTP/1.1 и WebSocket; минимальный overhead |
| **Pydantic** | v2 | Валидация данных | Интегрирован в FastAPI; строгая типизация моделей запросов/ответов; автоматическая сериализация |

### 2.2. NLP и машинное обучение

| Технология | Назначение | Обоснование выбора |
|---|---|---|
| **Sentence-Transformers** (paraphrase-multilingual-MiniLM-L12-v2) | Генерация эмбеддингов | Мультиязычная модель (50+ языков, включая русский и английский); компактный размер (118 МБ); 384-мерные эмбеддинги дают хороший баланс качества и скорости |
| **NLTK** (SnowballStemmer) | Стемминг для нормализации | Поддержка русского и английского языков; проверенный алгоритм Snowball; не требует GPU |
| **PyTorch** (CPU) | Runtime для Sentence-Transformers | Используется CPU-версия для минимизации размера образа и стоимости хостинга; достаточная производительность для inference на небольших текстах |
| **scikit-learn** (KMeans) | Кластеризация навыков | Группировка навыков в тематические треки для рекомендаций при смене профессии |

### 2.3. Внешние AI-сервисы

| Сервис | Назначение | Обоснование выбора |
|---|---|---|
| **OpenAI GPT-4o** | Извлечение навыков из резюме; генерация плана развития | Высокое качество работы с русскоязычным текстом; поддержка JSON-режима для структурированных ответов; настраиваемая «температура» генерации |
| **Qdrant Cloud** | Векторная база данных для RAG | REST API без тяжёлых зависимостей (gRPC/protobuf); облачный хостинг; поддержка фильтрации по payload; косинусная метрика из коробки |

### 2.4. Фронтенд

| Технология | Версия | Назначение | Обоснование выбора |
|---|---|---|---|
| **React** | 19 | UI-фреймворк | Компонентный подход; развитая экосистема; декларативное описание интерфейса |
| **TypeScript** | 5.9 | Типизация | Строгая типизация снижает количество runtime-ошибок; улучшает автодополнение и рефакторинг |
| **Vite** | 7 | Сборщик | Мгновенный HMR при разработке; оптимизированная production-сборка через Rollup; нативная поддержка TypeScript |
| **Tailwind CSS** | 4 | Стилизация | Utility-first подход ускоряет вёрстку; отсутствие конфликтов имён классов; автоматическое удаление неиспользуемых стилей при сборке |
| **React Markdown** + remark-gfm | Рендеринг Markdown | Безопасный рендеринг серверного Markdown; поддержка таблиц, strikethrough и других расширений GFM |
| **Lucide React** | Иконки | Лёгкая библиотека SVG-иконок; tree-shakeable (в бандл попадают только используемые) |
| **React Dropzone** | Загрузка файлов | Drag-and-drop зона для PDF; поддержка валидации типов файлов |

### 2.5. Инфраструктура

| Технология | Назначение | Обоснование выбора |
|---|---|---|
| **Docker** (multi-stage build) | Контейнеризация | Stage 1: Node.js собирает фронтенд; Stage 2: Python запускает бэкенд. Единый образ упрощает деплой |
| **Railway** | Облачный хостинг | Автоматический деплой из GitHub; управление переменными окружения; бесплатный SSL; поддержка Dockerfile |

---

## 3. Структура данных

### 3.1. База навыков (`data/clean_skills.json`)

JSON-массив из ~6 900 записей. Каждая запись описывает навык, привязанный к профессии, с индикаторами по трём уровням владения:

- **Basic** — применяет в типовых ситуациях;
- **Proficiency** — применяет в нестандартных ситуациях;
- **Advanced** — может обучать других.

Поля: название навыка, привязка к профессии (внутреннее название скиллсета), текстовые описания индикаторов по уровням, примеры задач на развитие, категория.

### 3.2. Атлас параметров (`data/atlas_params_clean.json`)

JSON-массив параметров карьерного роста (~10 параметров: автономность, масштаб задач, сложность, коммуникация и др.). Для каждого параметра заданы ожидания по пяти грейдам (Junior → Expert). Атлас-параметры применяются ко всем профессиям и отражают уровень зрелости специалиста.

### 3.3. Словарь синонимов (`data/skill_synonyms.json`)

Словарь вида `{синоним: каноническое_название}`. Используется для нормализации пользовательского ввода — например, «питон» → «Python», «управление проектами» → «Управление проектами».

---

## 4. Модули бизнес-логики

### 4.1. Загрузка и индексация данных (`data_loader.py`)

При инициализации загружает JSON-файлы и строит словари для быстрого доступа:

- `skills_map` — навык → объект навыка;
- `atlas_map` — параметр → объект параметра;
- маппинги между внутренними и отображаемыми названиями профессий.

Метод `get_role_requirements(role, grade)` возвращает словарь `{навык/параметр: требуемый_уровень}` для заданной роли и грейда. Атлас-параметры добавляются к каждой роли автоматически.

### 4.2. Нормализация навыков (`skill_normalizer.py`)

Реализует цепочку преобразований для приведения пользовательского ввода к канонической форме:

1. **Точное совпадение** — проверка в множестве канонических навыков;
2. **Нормализация** — приведение к нижнему регистру, удаление лишних пробелов, исправление типичных опечаток;
3. **Стемминг** — извлечение основы слова через NLTK SnowballStemmer с автоматическим определением языка (русский/английский по наличию кириллицы);
4. **Поиск по синонимам** — проверка в словаре `skill_synonyms.json`.

Паттерн проектирования — **цепочка ответственности**: каждый этап выполняется только если предыдущий не дал результата.

### 4.3. RAG-сервис (`rag_service.py`)

Модуль семантического поиска, реализующий паттерн Retrieval-Augmented Generation:

**Индексация.** Скрипт `build_rag_index.py` формирует текстовые описания для каждого навыка и параметра, генерирует 384-мерные эмбеддинги через Sentence-Transformers и загружает их в Qdrant с метаданными (тип, название, профессия).

**Поиск.** Функция `retrieve(query, top_k, score_threshold)` выполняет векторный поиск по косинусной близости. Порог score_threshold (по умолчанию 0.35) отсекает нерелевантные результаты.

**Ключевые функции:**

- `suggest_skills(query)` — подсказки навыков при вводе (порог 0.35);
- `map_to_canonical_skill(input)` — маппинг пользовательского навыка в каноническое название (порог 0.82 — высокая уверенность);
- `rank_opportunities(user_skills, opportunities)` — семантическое ранжирование профессий для сценария «Исследование возможностей»;
- `get_rag_context_for_plan(summary, target)` — извлечение контекста для генерации плана.

Взаимодействие с Qdrant реализовано через REST API (HTTP), что позволяет избежать тяжёлых зависимостей gRPC/protobuf. Все тяжёлые зависимости (Sentence-Transformers, PyTorch) загружаются лениво — только при первом обращении.

### 4.4. Анализ разрывов (`gap_analyzer.py`)

Сопоставляет текущие навыки пользователя с требованиями целевой роли:

1. Для каждого требования вычисляется дельта: `Δ = требуемый_уровень − текущий_уровень`.
2. Навыки разделяются на атлас-параметры и профессиональные навыки.
3. Каждому разрыву присваивается приоритет:
   - **Приоритет 1** (критический): Δ ≥ 2;
   - **Приоритет 2** (умеренный): Δ ≥ 1;
   - **Приоритет 3** (незначительный): Δ < 1.
4. Вычисляется процент соответствия: `match% = (сильные / всего) × 100`.
5. Результаты сортируются по убыванию дельты.

### 4.5. Обработка сценариев

Система поддерживает три сценария карьерного развития:

**«Следующий грейд»** (`next_grade_service.py`). Определяет следующий грейд в последовательности Junior → Middle → Senior → Lead → Expert. Загружает требования для целевого грейда, формирует описание ожиданий по атлас-параметрам (что ожидается на текущем уровне и чего требует следующий), строит связи между навыками и параметрами через RAG.

**«Смена профессии»** (`switch_profession_service.py`). Загружает требования целевой роли на уровне Middle. Определяет базовый уровень (на один грейд ниже целевого) для сравнения. Вычисляет совпадающие и недостающие навыки. Использует кластеризацию навыков (KMeans на эмбеддингах) для формирования рекомендуемых треков развития.

**«Исследование возможностей»** (`explore_recommendations.py`). Перебирает все профессии на грейдах Junior/Middle/Senior, вычисляет процент пересечения навыков. Семантически ранжирует результаты через RAG. Дедуплицирует и категоризирует:
- **Ближайшие** (совпадение ≥ 15%) — профессии, до которых проще всего дойти;
- **Смежные** (5–15%) — требуют освоения нескольких новых навыков;
- **Дальние** (< 5%) — потребуют значительного переобучения.

### 4.6. Генерация плана (`plan_generator.py`)

Использует GPT-4o для формирования плана по модели 70/20/10:
- **70%** — обучение через опыт (практические задачи);
- **20%** — обучение через общение (менторство, обратная связь);
- **10%** — формальное обучение (курсы, книги).

Промпт включает: роль (карьерный консультант), цель пользователя, тип сценария, сжатую диагностику (до 1 000 символов) и RAG-контекст. Температура генерации — 0.3 (низкая вариативность для предсказуемости). Реализован механизм повторных попыток (до 3 раз) с экспоненциальной задержкой. При недоступности API возвращается шаблонный план.

### 4.7. Парсинг резюме (`resume_parser.py`)

Двухэтапный процесс извлечения навыков из PDF:

1. **Извлечение текста** — библиотека pypdf читает все страницы PDF, объединяя текст. Результат обрезается до 14 000 символов для соблюдения лимитов контекстного окна.
2. **Извлечение навыков** — текст передаётся в GPT-4o с системным промптом, инструктирующим извлечь навыки и оценить уровень владения (1–3). Используется JSON response format для структурированного ответа. Температура — 0.1 (минимальная вариативность).

Извлечённые навыки постобрабатываются: каждый маппится в каноническое название через `rag_service.map_to_canonical_skill()`, а числовой уровень конвертируется в шкалу фронтенда (1 → 1, 2 → 1.5, 3 → 2).

---

## 5. REST API

Бэкенд предоставляет шесть эндпоинтов:

| Метод | Путь | Назначение |
|---|---|---|
| GET | `/api/professions` | Список доступных профессий |
| GET | `/api/skills-for-role?profession=...` | Навыки скиллсета для профессии |
| GET | `/api/suggest-skills?q=...` | Подсказки навыков (синонимы + RAG) |
| POST | `/api/analyze-resume` | Загрузка PDF, извлечение навыков |
| POST | `/api/plan` | Построение плана развития |
| GET | `/health` | Проверка состояния сервиса |

Эндпоинт `/api/plan` принимает JSON:
```json
{
  "profession": "Product Manager",
  "grade": "Специалист (Middle)",
  "skills": [{"name": "SQL", "level": 1.5}],
  "scenario": "Следующий грейд",
  "target_profession": null
}
```

И возвращает:
```json
{
  "markdown": "# Ваш план развития\n...",
  "role_titles": ["Data Analyst", "BI-аналитик"]
}
```

Поле `role_titles` присутствует только в сценарии «Исследование возможностей». Ошибки возвращаются с HTTP-кодами 400 (валидация), 503 (отсутствует API-ключ) и 500 (внутренняя ошибка).

Все эндпоинты за исключением catch-all маршрута определены явно, что гарантирует их приоритет при маршрутизации FastAPI. Catch-all маршрут `/{path:path}` раздаёт файлы React SPA из `frontend/dist` с fallback на `index.html`.

---

## 6. Фронтенд

### 6.1. Архитектура

Фронтенд реализован как одностраничное приложение (SPA) с пятью экранами, объединёнными единым состоянием на уровне корневого компонента `App`. Навигация между экранами управляется конечным автоматом:

```
Welcome → GoalSetup → Skills → Confirmation → Result
                                                  ↓
                                              (reset → Welcome)
```

Состояние приложения (`AppState`) включает: выбранную профессию, сценарий, грейд, целевую профессию и массив навыков с уровнями. Состояние передаётся в дочерние компоненты через props; обратная связь — через callback-функции.

### 6.2. Экраны

**Welcome** — лендинг с описанием продукта, тремя ценностными предложениями и CTA-кнопкой. Секция «Как это работает» доступна по якорной ссылке с плавной прокруткой.

**GoalSetup** — форма настройки цели. При монтировании загружает список профессий через `/api/professions`. Поле «Целевая профессия» отображается условно — только при сценарии «Смена профессии». Валидация перед переходом проверяет заполненность обязательных полей.

**Skills** — основной продуктовый экран. Блок загрузки резюме использует React Dropzone для drag-and-drop с обработкой состояний: загрузка, пустой результат, ошибка формата (400), недоступность AI-модели (503). Блок ручного ввода реализует debounce-поиск (250 мс) через `/api/suggest-skills` с выпадающим списком подсказок. Дополнительно отображаются кнопки быстрого добавления навыков профессии (из `/api/skills-for-role`). Каждый добавленный навык представлен карточкой с сегментированным контролом уровня (5 значений: 0, 0.5, 1, 1.5, 2) и кнопкой удаления.

**Confirmation** — экран проверки: сводка выбранных параметров и топ-5 навыков. При нажатии CTA вызывает `/api/plan` и отображает спиннер с пояснительным текстом. Ошибки API показываются как inline-алерты.

**Result** — отображение плана. Markdown рендерится через ReactMarkdown с плагином remark-gfm (таблицы, зачёркивание). Автоматически строится оглавление из заголовков h2/h3, отображаемое как sticky-сайдбар на широких экранах. Панель действий: копирование в буфер обмена, скачивание .md-файла (генерация Blob на клиенте), сброс. Для сценария «Исследование возможностей» сверху отображаются чипсы подходящих ролей из `role_titles`.

### 6.3. Обработка ошибок и пограничных состояний

- **Health check** — при загрузке приложение проверяет `/health`. Если сервис недоступен, отображается экран-заглушка с кнопкой повторной проверки.
- **Ошибка 503** (нет OPENAI_API_KEY) — специальное предупреждение «Авторазбор резюме временно недоступен» с предложением добавить навыки вручную.
- **Ошибка 400** (не PDF) — сообщение с рекомендацией сохранить файл как PDF.
- **Пустой список навыков** — мотивирующее сообщение «Пока пусто. Добавьте 3–7 навыков...».
- **Сетевые ошибки** — универсальный алерт с предложением проверить соединение.

---

## 7. Деплой и контейнеризация

Приложение контейнеризировано с помощью multi-stage Dockerfile:

**Stage 1 (Node.js 20)** — установка npm-зависимостей и сборка React-приложения через Vite. Результат — оптимизированные статические файлы в `frontend/dist`.

**Stage 2 (Python 3.12)** — установка Python-зависимостей, копирование исходного кода и собранного фронтенда из первого стейджа. Запуск через `python api.py`, который самостоятельно читает переменную окружения `PORT`.

Деплой выполняется на Railway с автоматическим деплоем из ветки `main` GitHub-репозитория. Railway предоставляет SSL-терминацию, управление переменными окружения и автоматический restart.

---

## 8. Обоснование ключевых архитектурных решений

**Монолитный деплой (бэкенд + фронтенд в одном сервисе).** Упрощает инфраструктуру для MVP: не требуется настройка CORS между доменами, отдельный CDN для статики или балансировщик. FastAPI эффективно раздаёт статические файлы через `FileResponse`.

**RAG вместо fine-tuning.** Retrieval-Augmented Generation позволяет использовать актуальную базу навыков без переобучения модели. При обновлении данных достаточно переиндексировать Qdrant — без затрат на fine-tuning.

**Ленивая загрузка ML-зависимостей.** Тяжёлые библиотеки (Sentence-Transformers, PyTorch) загружаются только при первом обращении к RAG-функциям. Это ускоряет старт приложения и снижает потребление памяти при сценариях, не требующих семантического поиска.

**Взаимодействие с Qdrant через REST.** Отказ от официального Python-клиента (`qdrant-client`) в пользу прямых HTTP-запросов (`urllib`) исключает тяжёлые зависимости gRPC и protobuf, что уменьшает размер Docker-образа и количество потенциальных конфликтов версий.

**Шкала навыков с дробными значениями (0 / 0.5 / 1 / 1.5 / 2).** Обеспечивает более гранулярную оценку, чем трёхуровневая шкала, при этом остаётся интуитивно понятной пользователю. Значения напрямую соответствуют внутренним уровням бэкенда, что исключает необходимость преобразования.

**React + TypeScript для фронтенда.** Строгая типизация TypeScript снижает количество runtime-ошибок в типах данных, передаваемых между экранами и API-клиентом. Типы `Skill`, `AppState`, `PlanRequest` описаны один раз и используются сквозь всё приложение.
