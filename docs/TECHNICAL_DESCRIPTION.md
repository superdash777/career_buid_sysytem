# Техническое описание реализации

## 1. Общая архитектура системы

Career Copilot представляет собой веб-приложение с клиент-серверной архитектурой, объединяющее методы NLP, семантического поиска (RAG) и генеративного ИИ для построения персонализированных планов карьерного развития.

Система развёрнута как единый сервис: Python-бэкенд обслуживает REST API и одновременно раздаёт статические файлы React-фронтенда. Такой подход исключает необходимость в отдельном веб-сервере и упрощает деплой.

### 1.1. Архитектурная схема

```
┌────────────────────────────────────────────────────────────────────────┐
│                         КЛИЕНТ (Браузер)                               │
│                                                                        │
│   React 19 · TypeScript 5.9 · Tailwind CSS 4 · Vite 7                │
│                                                                        │
│   ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌────────┐ │
│   │ Welcome  │→ │ GoalSetup│→ │  Skills  │→ │ Confirm  │→ │ Result │ │
│   └──────────┘  └──────────┘  └──────────┘  └──────────┘  └────────┘ │
│        ↑                                                        ↑     │
│        └────────── History API (browser back / forward) ────────┘     │
│                    sessionStorage (state persistence)                   │
│                                                                        │
│   API-клиент: fetch + AbortController (отмена при размонтировании)    │
│   ErrorBoundary → ThemeProvider → App → Screen → Components           │
│                                                                        │
└────────────────────────────┬───────────────────────────────────────────┘
                             │ HTTP (JSON / multipart)
┌────────────────────────────▼───────────────────────────────────────────┐
│                      FastAPI (api.py)                                   │
│   REST API + SPA fallback (frontend/dist)                              │
├────────────────────────────────────────────────────────────────────────┤
│                       Бизнес-логика                                    │
│  scenario_handler → gap_analyzer → output_formatter → plan_generator  │
│  next_grade_service / switch_profession_service / explore_recommend.   │
├────────────────────────────────────────────────────────────────────────┤
│                       Данные и NLP                                     │
│  data_loader (JSON) · skill_normalizer (pymorphy3) · rag_service      │
│  resume_parser (pypdf + GPT-4o)                                       │
├────────────────────────────────────────────────────────────────────────┤
│                       Внешние сервисы                                  │
│  OpenAI API (GPT-4o)           Qdrant Cloud (опционально)             │
└────────────────────────────────────────────────────────────────────────┘
```

### 1.2. Поток данных

Обработка запроса на построение плана проходит через следующие этапы:

1. **Ввод данных** — пользователь выбирает профессию, грейд, сценарий и добавляет навыки (вручную или из резюме).
2. **Маршрутизация сценария** — `scenario_handler` определяет тип запроса и загружает требования для целевой роли/грейда из `data_loader`.
3. **Анализ разрывов** — `gap_analyzer` сопоставляет навыки пользователя с требованиями роли, вычисляет дельты и приоритеты.
4. **Обогащение контекстом** — `rag_service` извлекает семантически релевантные фрагменты из векторной базы для пояснения разрывов.
5. **Форматирование диагностики** — `output_formatter` собирает структурированный отчёт (шаг 1).
6. **Генерация плана** — `plan_generator` передаёт диагностику и RAG-контекст в GPT-4o для формирования плана по модели 70/20/10 (шаг 2).
7. **Отображение** — фронтенд рендерит Markdown с оглавлением, кнопками копирования/скачивания и оценкой полезности.

---

## 2. Технологии и инструменты

### 2.1. Бэкенд

| Технология | Версия | Назначение | Обоснование выбора |
|---|---|---|---|
| **Python** | 3.12 | Основной язык | Богатая экосистема ML/NLP-библиотек; поддержка типизации |
| **FastAPI** | ≥ 0.100 | REST API фреймворк | Асинхронность из коробки; автогенерация OpenAPI-документации; Pydantic-валидация |
| **Uvicorn** | ≥ 0.22 | ASGI-сервер | Стандартный сервер для FastAPI; минимальный overhead |
| **Pydantic** | v2 | Валидация данных | Интегрирован в FastAPI; строгая типизация моделей запросов/ответов |

### 2.2. NLP и машинное обучение

| Технология | Назначение | Обоснование выбора |
|---|---|---|
| **pymorphy3** | Лемматизация русского языка | Точнее стемминга: «разработка» и «разработчик» приводятся к одной лемме «разработка». Snowball-стемминг давал «разработк» vs «разработчик» — не совпадали |
| **Sentence-Transformers** (paraphrase-multilingual-MiniLM-L12-v2) | Генерация эмбеддингов для RAG | Мультиязычная модель (50+ языков); компактная (118 МБ); 384-мерные эмбеддинги |
| **NLTK** (SnowballStemmer) | Стемминг английских слов | Используется как fallback для англоязычных навыков (Python, SQL и т.д.) |
| **PyTorch** (CPU) | Runtime для Sentence-Transformers | CPU-версия минимизирует размер образа; достаточна для inference |
| **scikit-learn** (KMeans) | Кластеризация навыков | Группировка в тематические треки при смене профессии |

### 2.3. Внешние AI-сервисы

| Сервис | Назначение | Обоснование выбора |
|---|---|---|
| **OpenAI GPT-4o** | Извлечение навыков из резюме; генерация плана развития | Высокое качество работы с русскоязычным текстом; JSON-режим для структурированных ответов; настраиваемая температура |
| **Qdrant Cloud** | Векторная база данных для RAG | REST API без тяжёлых зависимостей; облачный хостинг; фильтрация по payload; косинусная метрика |

### 2.4. Фронтенд

| Технология | Версия | Назначение | Обоснование выбора |
|---|---|---|---|
| **React** | 19 | UI-фреймворк | Компонентный подход; хуки для состояния и эффектов; развитая экосистема |
| **TypeScript** | 5.9 | Типизация | Строгая типизация снижает runtime-ошибки; типы `Skill`, `AppState`, `PlanRequest` сквозные |
| **Vite** | 7 | Сборщик | Мгновенный HMR; оптимизированная production-сборка через Rollup |
| **Tailwind CSS** | 4 | Стилизация | Utility-first; CSS-переменные для тем (dark/light); автоудаление неиспользуемых стилей |
| **React Markdown** + remark-gfm | Рендеринг Markdown | Безопасный рендеринг; поддержка таблиц, strikethrough и GFM-расширений |
| **Lucide React** | — | Иконки | Tree-shakeable SVG-иконки |
| **React Dropzone** | 15 | Загрузка файлов | Drag-and-drop зона для PDF с валидацией типов |

### 2.5. Инфраструктура

| Технология | Назначение | Обоснование выбора |
|---|---|---|
| **Docker** (multi-stage) | Контейнеризация | Stage 1: Node.js собирает фронтенд; Stage 2: Python запускает бэкенд. Единый образ |
| **Railway** | Облачный хостинг | Автодеплой из GitHub; управление переменными; SSL; поддержка Dockerfile |

---

## 3. Структура данных

### 3.1. База навыков (`data/clean_skills.json`)

JSON-массив из ~6 900 записей. Каждая запись описывает навык, привязанный к профессии, с индикаторами по трём уровням владения:

- **Basic** — применяет в типовых ситуациях;
- **Proficiency** — применяет в нестандартных ситуациях;
- **Advanced** — может обучать других.

Поля: название навыка, привязка к профессии (внутреннее название скиллсета), текстовые описания индикаторов по уровням, примеры задач на развитие, категория.

### 3.2. Атлас параметров (`data/atlas_params_clean.json`)

JSON-массив параметров карьерного роста (~10 параметров: автономность, масштаб задач, сложность, коммуникация и др.). Для каждого параметра заданы ожидания по пяти грейдам (Junior → Expert). Атлас-параметры применяются ко всем профессиям и отражают уровень зрелости специалиста.

### 3.3. Словарь синонимов (`data/skill_synonyms.json`)

Словарь вида `{синоним: каноническое_название}`. Используется для нормализации пользовательского ввода — например, «питон» → «Python», «управление проектами» → «Управление проектами».

---

## 4. Модули бизнес-логики

### 4.1. Загрузка и индексация данных (`data_loader.py`)

При инициализации загружает JSON-файлы и строит словари для быстрого доступа:

- `skills_map` — навык → объект навыка;
- `atlas_map` — параметр → объект параметра;
- маппинги между внутренними и отображаемыми названиями профессий.

Метод `get_role_requirements(role, grade)` возвращает словарь `{навык/параметр: требуемый_уровень}` для заданной роли и грейда. Навыки используют 3-уровневую шкалу (Basic/Proficiency/Advanced), атлас-параметры — 5-уровневую ordinal-шкалу (Junior→Expert).

### 4.2. Нормализация навыков (`skill_normalizer.py`)

Реализует цепочку преобразований для приведения пользовательского ввода к канонической форме:

1. **Точное совпадение** — проверка в множестве канонических навыков;
2. **Нормализация** — приведение к нижнему регистру, удаление лишних пробелов, исправление типичных опечаток;
3. **Лемматизация** — pymorphy3 для русского языка (морфологический анализ: «разработка», «разработчик», «разработки» → «разработка»), NLTK SnowballStemmer для английского;
4. **Поиск по синонимам** — проверка в словаре `skill_synonyms.json`.

Паттерн проектирования — **цепочка ответственности**: каждый этап выполняется только если предыдущий не дал результата.

> **Почему pymorphy3, а не NLTK Snowball для русского:** стемминг отсекает окончания грубо — «разработка» → «разработк», «разработчик» → «разработчик». Эти формы не совпадают, хотя семантически связаны. Лемматизация через pymorphy3 приводит оба слова к лемме «разработка», что даёт корректное сопоставление.

### 4.3. RAG-сервис (`rag_service.py`)

Модуль семантического поиска, реализующий паттерн Retrieval-Augmented Generation:

**Индексация.** Скрипт `build_rag_index.py` формирует текстовые описания для каждого навыка и параметра, генерирует 384-мерные эмбеддинги через Sentence-Transformers и загружает их в Qdrant с метаданными (тип, название, профессия).

**Поиск.** Функция `retrieve(query, top_k, score_threshold)` выполняет векторный поиск по косинусной близости. Порог score_threshold (по умолчанию 0.35) отсекает нерелевантные результаты.

**Ключевые функции:**

- `suggest_skills(query)` — подсказки навыков при вводе (порог 0.35);
- `map_to_canonical_skill(input)` — маппинг пользовательского навыка в каноническое название (порог 0.82 — высокая уверенность);
- `rank_opportunities(user_skills, opportunities)` — семантическое ранжирование профессий для сценария «Исследование возможностей»;
- `get_rag_context_for_plan(summary, target)` — извлечение контекста для генерации плана.

Взаимодействие с Qdrant реализовано через REST API (HTTP), что позволяет избежать тяжёлых зависимостей gRPC/protobuf. Все тяжёлые зависимости (Sentence-Transformers, PyTorch) загружаются лениво — только при первом обращении.

### 4.4. Анализ разрывов (`gap_analyzer.py`)

Сопоставляет текущие навыки пользователя с требованиями целевой роли:

1. Для каждого требования вычисляется дельта: `Δ = требуемый_уровень − текущий_уровень`.
2. Навыки разделяются на атлас-параметры и профессиональные навыки.
3. Каждому разрыву присваивается приоритет:
   - **Приоритет 1** (критический): Δ ≥ 2;
   - **Приоритет 2** (умеренный): Δ ≥ 1;
   - **Приоритет 3** (незначительный): Δ < 1.
4. Вычисляется процент соответствия: `match% = (сильные / всего) × 100`.
5. Результаты сортируются по убыванию дельты.

### 4.5. Обработка сценариев

Система поддерживает три сценария карьерного развития:

**«Следующий грейд»** (`next_grade_service.py`). Определяет следующий грейд в последовательности Junior → Middle → Senior → Lead → Expert. Загружает требования для целевого грейда, формирует описание ожиданий по атлас-параметрам, строит связи между навыками и параметрами через RAG.

**«Смена профессии»** (`switch_profession_service.py`). Загружает требования целевой роли на уровне Middle. Определяет базовый уровень для сравнения. Вычисляет совпадающие и недостающие навыки. Использует кластеризацию навыков (KMeans на эмбеддингах) для формирования рекомендуемых треков развития.

**«Исследование возможностей»** (`explore_recommendations.py`). Перебирает все профессии на грейдах Junior/Middle/Senior, вычисляет процент пересечения навыков. Семантически ранжирует результаты через RAG. Категоризирует:
- **Ближайшие** (совпадение ≥ 15%) — профессии, до которых проще всего дойти;
- **Смежные** (5–15%) — требуют освоения нескольких новых навыков;
- **Дальние** (< 5%) — потребуют значительного переобучения.

### 4.6. Генерация плана (`plan_generator.py`)

Использует GPT-4o для формирования плана по модели 70/20/10:
- **70%** — обучение через опыт (практические задачи);
- **20%** — обучение через общение (менторство, обратная связь);
- **10%** — формальное обучение (курсы, книги).

Промпт включает: роль (карьерный консультант), цель пользователя, тип сценария, сжатую диагностику (до 1 000 символов) и RAG-контекст. Температура генерации — 0.3 (низкая вариативность для предсказуемости). Реализован механизм повторных попыток (до 3 раз) с экспоненциальной задержкой. При недоступности API возвращается шаблонный план.

### 4.7. Парсинг резюме (`resume_parser.py`)

Двухэтапный процесс извлечения навыков из PDF:

1. **Извлечение текста** — библиотека pypdf читает все страницы PDF. Результат обрезается до 14 000 символов.
2. **Извлечение навыков** — текст передаётся в GPT-4o с системным промптом, содержащим полный список канонических навыков. Используется JSON response format. Температура — 0.1.

Извлечённые навыки постобрабатываются: маппинг в каноническое название через `rag_service.map_to_canonical_skill()`, конвертация уровня в шкалу фронтенда (1→1, 2→1.5, 3→2).

---

## 5. REST API

Бэкенд предоставляет шесть эндпоинтов:

| Метод | Путь | Назначение |
|---|---|---|
| GET | `/api/professions` | Список доступных профессий |
| GET | `/api/skills-for-role?profession=...` | Навыки скиллсета для профессии |
| GET | `/api/suggest-skills?q=...` | Подсказки навыков (синонимы + RAG) |
| POST | `/api/analyze-resume` | Загрузка PDF, извлечение навыков |
| POST | `/api/plan` | Построение плана развития |
| GET | `/health` | Проверка состояния сервиса |

Эндпоинт `/api/plan` принимает JSON:
```json
{
  "profession": "Product Manager",
  "grade": "Специалист (Middle)",
  "skills": [{"name": "SQL", "level": 1.5}],
  "scenario": "Следующий грейд",
  "target_profession": null
}
```

И возвращает:
```json
{
  "markdown": "# Ваш план развития\n...",
  "role_titles": ["Data Analyst", "BI-аналитик"]
}
```

Поле `role_titles` присутствует только в сценарии «Исследование возможностей». Ошибки: 400 (валидация), 503 (нет API-ключа), 500 (внутренняя ошибка).

Catch-all маршрут `/{path:path}` раздаёт React SPA из `frontend/dist` с fallback на `index.html`.

---

## 6. Фронтенд

### 6.1. Архитектура

SPA с пятью экранами, управляемое конечным автоматом:

```
Welcome → GoalSetup → Skills → Confirmation → Result
                                                 ↓
                                             reset → Welcome
```

**Состояние** (`AppState`) хранится в `App.tsx` и включает: профессию, сценарий, грейд, целевую профессию, массив навыков. Передаётся в компоненты через props; обратная связь — через callback-функции.

**Persistence:** состояние автоматически сериализуется в `sessionStorage` при каждом изменении. При загрузке страницы восстанавливается. F5 / случайный refresh не теряет прогресс.

**Навигация:** каждый переход записывает хэш в URL через `history.pushState`. Событие `popstate` обрабатывает кнопку «Назад» браузера, возвращая на предыдущий экран вместо ухода с сайта.

**Error Boundary:** корневой `ErrorBoundary` перехватывает непредвиденные ошибки и показывает экран восстановления с кнопкой «Начать заново».

### 6.2. Экраны

**Welcome** — лендинг с описанием продукта, тремя шагами и CTA-кнопкой.

**GoalSetup** — форма настройки цели с прогрессивным раскрытием:
- Сначала показывается только выбор профессии (SearchableSelect с фильтрацией);
- После выбора профессии появляются карточки сценариев;
- После выбора сценария появляется грейд с контекстным описанием.
- Загрузка профессий — skeleton-экран вместо спиннера.
- AbortController для отмены запросов при размонтировании.

**Skills** — основной продуктовый экран:
- Drag-and-drop загрузка PDF с подсветкой новых навыков (бейдж «новый»);
- Поиск навыков с debounce (250мс), keyboard navigation (↑↓, Enter, Escape), ARIA-атрибуты;
- Рекомендуемые навыки профессии с группировкой (6 видимых + «Показать все»);
- Карточки навыков с 5-уровневым переключателем и undo-удалением (toast);
- Индикатор качества (progress bar: красный < 3 навыков → жёлтый → зелёный ≥ 5).

**Confirmation** — экран проверки:
- Сводка параметров + навыки с возможностью развернуть полный список;
- Упрощённое описание процесса генерации (без технического жаргона).

**Result** — отображение плана:
- Markdown через ReactMarkdown + remark-gfm;
- Desktop: sticky TOC-сайдбар из h2/h3;
- Mobile: кнопка «Оглавление» → bottom-sheet с навигацией;
- Копирование в буфер, скачивание .md;
- Виджет оценки полезности (thumbs up/down).

### 6.3. Обработка ошибок и пограничных состояний

- **Health check** — при загрузке проверяет `/health`. Если сервис недоступен — экран-заглушка с повторной проверкой.
- **Ошибка 503** (нет OPENAI_API_KEY) — предупреждение с предложением ручного ввода.
- **Ошибка 400** — сообщение о формате файла.
- **Пустой результат** — если пользователь попал на экран Result без плана — информативное сообщение с кнопкой возврата.
- **Undo** — удаление навыка показывает toast с кнопкой «Отменить» (4 секунды).
- **Сетевые ошибки** — универсальный алерт с предложением проверить соединение.

### 6.4. Дизайн-система

**Темы:** 12 CSS-переменных переключаются классом `.dark` на `<html>`. Тема сохраняется в `localStorage`, при первом визите определяется из `prefers-color-scheme`.

| Токен | Light | Dark |
|---|---|---|
| `--color-surface` | #f8fafc | #0f172a |
| `--color-accent` | #4f46e5 (индиго) | #818cf8 |
| `--color-text-primary` | #0f172a | #f1f5f9 |

**Анимации:** `.fade-in` (opacity), `.slide-up` (translateY), `.skill-card-enter` (translateX + scale).

**Типографика:** Inter, system-ui, sans-serif. Tailwind-шкала размеров.

**Компонентные классы:** `.btn-primary`, `.btn-secondary`, `.card`, `.input-field`, `.label`, `.helper`.

---

## 7. Деплой и контейнеризация

Multi-stage Dockerfile:

**Stage 1 (Node.js 20)** — установка npm-зависимостей и сборка React-приложения через Vite. Результат — оптимизированные статические файлы в `frontend/dist`.

**Stage 2 (Python 3.12)** — установка Python-зависимостей, копирование исходного кода и собранного фронтенда. Запуск через `python api.py` (читает `PORT` из env).

Деплой на Railway с автодеплоем из `main`. Railway предоставляет SSL-терминацию, переменные окружения и автоматический restart.

---

## 8. Обоснование ключевых архитектурных решений

| Решение | Обоснование |
|---------|-------------|
| **Монолитный деплой** | Упрощает инфраструктуру для MVP: нет CORS, нет отдельного CDN |
| **RAG вместо fine-tuning** | При обновлении данных достаточно переиндексировать — без затрат на переобучение |
| **pymorphy3 вместо NLTK Snowball** | Лемматизация точнее стемминга: «разработка» и «разработчик» → одна лемма |
| **Ленивая загрузка ML** | PyTorch + Sentence-Transformers грузятся только при первом RAG-запросе |
| **Qdrant через REST** | Без gRPC/protobuf — меньше зависимостей, меньший Docker-образ |
| **sessionStorage** | Состояние wizard-а переживает F5, но не закрытие вкладки (приватность) |
| **History API вместо React Router** | Лёгкое решение для линейного flow; нет лишних зависимостей |
| **AbortController** | Предотвращает race conditions при быстрой навигации |
| **Toast + undo** | Мгновенное удаление с отменой лучше модального подтверждения |
| **Progressive disclosure** | Снижает cognitive load: поля появляются по мере заполнения |
